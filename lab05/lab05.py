# -*- coding: utf-8 -*-
"""lab05.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a-406V7_xo63bU4WdMimv6eGxHTpeDSs

**1 Cel/Zakres**

• Drzewa decyzyjne: klasyfikacja i regresja.

• Wizualizacja drzew.

**2 Przygotowanie danych**

Dane sa poniższe zbiory danych: data_breast_cancer i df.

```
from sklearn import datasets
data_breast_cancer = datasets.load_breast_cancer(as_frame=True)
print(data_breast_cancer['DESCR'])
```
"""

from sklearn import datasets
data_breast_cancer = datasets.load_breast_cancer(as_frame=True)
import numpy as np
import pandas as pd
size = 300
X = np.random.rand(size)*5-2.5
w4, w3, w2, w1, w0 = 1, 2, 1, -4, 2
y = w4*(X**4) + w3*(X**3) + w2*(X**2) + w1*X + w0 + np.random.randn(size)*8-4
df = pd.DataFrame({'x': X, 'y': y})
df.plot.scatter(x='x',y='y')

"""**3 Klasyfikacja**
1. Użyj drzew decyzyjnych do klasyfikacji zbioru danych data_breast_cancer dla cech mean
texture i mean symmetry.
2. Podziel ww. zbiór na uczący i testujący w proprcjach 80:20.
3. Znajdź odpowiednią głębokośc drzewa decyzyjnego, tak aby osiągnąć maksymalną wartość f1
(uwaga: sprawdź dla zbioru uczącego i testowego).
4
4. Wygenruj rysunek drzewa decyzyjnego w pliku bc.png.
1 pkt
5. Zapisz w pliku Pickle f1acc_tree.pkl listę zawierającą: głebokość drzewa, f1 dla zbioru
uczącego, f1 dla zbioru testowego, dokładność (accuracy) dla zbioru uczącego, dokładność
(accuracy) dla zbioru testowego.

"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score
from sklearn.metrics import mean_squared_error
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
import pickle

max_depth = 3
tree_result = [] #lista przechowująca wyniki drzewa decyzyjnego
#2.Podziel ww. zbiór na uczący i testujący w proprcjach 80:20.
X_train, X_test, y_train, y_test = train_test_split(data_breast_cancer['data'][['mean texture', 'mean symmetry']], data_breast_cancer['target'], test_size=0.2)
tree_clf = DecisionTreeClassifier(max_depth=max_depth).fit(X_train, y_train)
y_train_predict = tree_clf.predict(X_train)
y_test_predict = tree_clf.predict(X_test)

tree_result.append(tree_clf.get_depth())
tree_result.append(f1_score(y_train, y_train_predict))
tree_result.append(f1_score(y_test, y_test_predict))
tree_result.append(tree_clf.score(X_train, y_train))
tree_result.append(tree_clf.score(X_test, y_test))

#3. Znajdź odpowiednią głębokośc drzewa decyzyjnego, tak aby osiągnąć maksymalną wartość f1 (uwaga: sprawdź dla zbioru uczącego i testowego).

best_depth = None
best_avg_f1 = -1

for depth in range(1, 10):
    temp_tree = DecisionTreeClassifier(max_depth=depth).fit(X_train, y_train)
    y_train_predict = temp_tree.predict(X_train)
    y_test_predict = temp_tree.predict(X_test)
    f1_train, f1_test = f1_score(y_train, y_train_predict), f1_score(y_test, y_test_predict)
    avg_f1 = (f1_test + f1_train) / 2

    print(f"Głębokość: {depth}, f1_train: {f1_train}, f1_test: {f1_test}, średnie f1: {avg_f1}")

    if avg_f1 > best_avg_f1:
        best_avg_f1 = avg_f1
        best_depth = depth

print(f"Najlepsza głębokość: {best_depth}")

#4. Wygenruj rysunek drzewa decyzyjnego w pliku bc.png. 1 pkt
from sklearn.tree import export_graphviz
from sklearn import tree
import graphviz
dot_data = tree.export_graphviz(tree_clf, out_file=None, feature_names=['mean texture', 'mean symmetry'], class_names=['malignant', 'benign'], rounded=True, filled=True)
graph = graphviz.Source(dot_data)

with open('bc.png', 'wb') as f:
    f.write(graph.pipe(format='png'))

#5. Zapisz w pliku Pickle f1acc_tree.pkl listę zawierającą: głebokość drzewa, f1 dla zbioru uczącego, f1 dla zbioru testowego, dokładność (accuracy) dla zbioru uczącego, dokładność (accuracy) dla zbioru testowego
with open('f1acc_tree.pkl', 'wb') as f:
    pickle.dump(tree_result, f)
print(tree_result)

"""**4 Regresja**
1. Użyj drzew decyzyjnych do budowy regresora na zbiorze danych df.
2. Podziel w/w zbiór na uczący i testujący w proprcjach 80/20.
3. Znajdź odpowiednią głębokośc drzewa decyzyjnego, tak aby wartość błędu średniokwadratowego (MSE), zarówno dla zbioru uczącego i testującego, były jak najmniejsze (uwaga na
overfitting).
4. Sporządź wykres wszystkich danych z df oraz predykcji regresora, porównaj wyniki z tymi
osiągniętymi dla regresji wielomianowej i KNN z poprzednich ćwiczeń.
5. Wygenruj rysunek drzewa decyzyjnego w pliku reg.png.
1 pkt
6. Zapisz w pliku Pickle mse_tree.pkl listę zawierającą: głebokość drzewa, MSE dla zbioru
uczącego, MSE dla zbioru testowego
"""

#1. Użyj drzew decyzyjnych do budowy regresora na zbiorze danych df.
#2. Podziel w/w zbiór na uczący i testujący w proprcjach 80/20.
X_train, X_test, y_train, y_test = train_test_split(X.reshape(-1,1), y.reshape(-1,1), test_size=0.2)
from sklearn.tree import DecisionTreeRegressor
tree_reg = DecisionTreeRegressor(max_depth=3).fit(X_train, y_train)
y_train_predict_reg = tree_reg.predict(X_train)
y_test_predict_reg = tree_reg.predict(X_test)
train_mse = mean_squared_error( y_train, y_train_predict_reg)
test_mse = mean_squared_error(y_test, y_test_predict_reg)

tree_results2 = []
tree_results2.append(tree_reg.get_depth())
tree_results2.append(train_mse)
tree_results2.append(test_mse)

#6. Zapisz w pliku Pickle mse_tree.pkl listę zawierającą: głebokość drzewa, MSE dla zbioru uczącego, MSE dla zbioru testowego
with open('mse_tree.pkl', 'wb') as f:
    pickle.dump(tree_results2, f)
print(tree_results2)

#3. Znajdź odpowiednią głębokośc drzewa decyzyjnego, tak aby wartość błędu średniokwadratowego (MSE), zarówno dla zbioru uczącego i testującego, były jak najmniejsze (uwaga na overfitting).

best_depth = None
min_combined_mse = float('inf')  # Inicjalizujemy najmniejsze MSE jako nieskończoność

for depth in range(1, 10):
    # Trenowanie modelu drzewa regresyjnego dla danej głębokości
    tree_reg_temp = DecisionTreeRegressor(max_depth=depth, random_state=42).fit(X_train, y_train)

    # Wykonanie predykcji na danych treningowych i testowych
    y_train_pred_reg, y_test_pred_reg = tree_reg_temp.predict(X_train), tree_reg_temp.predict(X_test)

    # Obliczenie MSE dla danych treningowych i testowych
    train_mse, test_mse = mean_squared_error(y_train, y_train_pred_reg), mean_squared_error(y_test, y_test_pred_reg)

    # Obliczenie łącznego MSE i aktualizacja najlepszej głębokości, jeśli to konieczne
    combined_mse = (train_mse + test_mse) / 2
    if combined_mse < min_combined_mse:
        min_combined_mse = combined_mse
        best_depth = depth

    print(f"Głębokość: {depth}, train_mse: {train_mse}, test_mse: {test_mse}, łączne_mse: {combined_mse}")

print(f"Najlepsza głębokość: {best_depth}")

import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from sklearn.neighbors import KNeighborsRegressor
from sklearn.linear_model import LinearRegression

#4. Sporządź wykres wszystkich danych z df oraz predykcji regresora, porównaj wyniki z tymi osiągniętymi dla regresji wielomianowej i KNN z poprzednich ćwiczeń.
# Polynomial regression
poly_features = PolynomialFeatures(degree=3, include_bias=False)
X_train_poly = poly_features.fit_transform(X_train)
X_test_poly = poly_features.fit_transform(X_test)
lin_reg_poly = LinearRegression().fit(X_train_poly, y_train)
lin_reg_poly_t = LinearRegression().fit(X_test_poly, y_test)
y_train_predict_poly = lin_reg_poly.predict(X_train_poly)
y_test_predict_poly = lin_reg_poly.predict(X_test_poly)

# KNN
knn = KNeighborsRegressor(n_neighbors=5)
knn.fit(X_train, y_train)
y_train_predict_knn = knn.predict(X_train)
y_test_predict_knn = knn.predict(X_test)

# Wykres danych i predykcji
plt.plot(X_train, y_train_predict_poly, label='poly train')
plt.plot(X_test, y_test_predict_poly, label='poly train')
plt.plot(X_train, y_train_predict_knn, label='knn train')
plt.plot(X_test, y_test_predict_knn, label='knn train')
plt.legend()
plt.show()

#5. Wygenruj rysunek drzewa decyzyjnego w pliku reg.png. 1 pkt
from sklearn.tree import export_graphviz
from sklearn import tree
import graphviz

dot_string = export_graphviz(tree_reg, out_file=None, rounded=True, filled=True)
graph = graphviz.Source(dot_string)

with open('reg.png', 'wb') as f:
    f.write(graph.pipe(format='png'))

"""**5 Prześlij raport**

Prześlij plik o nazwie lab05/lab95.py realizujący ww. ćwiczenia. Sprawdzane będzie, czy skrypt Pythona tworzy wszystkie wymagane pliki oraz czy ich zawartość jest poprawna.
"""